{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { LogLevel } from \"./ILogger\";\nimport { NullLogger } from \"./Loggers\";\n/** @private */\nvar Arg = /** @class */function () {\n  function Arg() {}\n  Arg.isRequired = function (val, name) {\n    if (val === null || val === undefined) {\n      throw new Error(\"The '\" + name + \"' argument is required.\");\n    }\n  };\n  Arg.isIn = function (val, values, name) {\n    // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\n    if (!(val in values)) {\n      throw new Error(\"Unknown \" + name + \" value: \" + val + \".\");\n    }\n  };\n  return Arg;\n}();\nexport { Arg };\n/** @private */\nexport function getDataDetail(data, includeContent) {\n  var length = null;\n  if (isArrayBuffer(data)) {\n    length = \"Binary data of length \" + data.byteLength;\n    if (includeContent) {\n      length += \". Content: '\" + formatArrayBuffer(data) + \"'\";\n    }\n  } else if (typeof data === \"string\") {\n    length = \"String data of length \" + data.length;\n    if (includeContent) {\n      length += \". Content: '\" + data + \"'.\";\n    }\n  }\n  return length;\n}\n/** @private */\nexport function formatArrayBuffer(data) {\n  var view = new Uint8Array(data);\n  // Uint8Array.map only supports returning another Uint8Array?\n  var str = \"\";\n  view.forEach(function (num) {\n    var pad = num < 16 ? \"0\" : \"\";\n    str += \"0x\" + pad + num.toString(16) + \" \";\n  });\n  // Trim of trailing space.\n  return str.substr(0, str.length - 1);\n}\n/** @private */\nexport function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, headers, token, response;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4 /*yield*/, accessTokenFactory()];\n        case 1:\n          token = _b.sent();\n          if (token) {\n            headers = (_a = {}, _a[\"Authorization\"] = \"Bearer \" + token, _a);\n          }\n          logger.log(LogLevel.Trace, \"(\" + transportName + \" transport) sending data. \" + getDataDetail(content, logMessageContent) + \".\");\n          return [4 /*yield*/, httpClient.post(url, {\n            content: content,\n            headers: headers\n          })];\n        case 2:\n          response = _b.sent();\n          logger.log(LogLevel.Trace, \"(\" + transportName + \" transport) request complete. Response status: \" + response.statusCode + \".\");\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n/** @private */\nexport function createLogger(logger) {\n  if (logger === undefined) {\n    return new ConsoleLogger(LogLevel.Information);\n  }\n  if (logger === null) {\n    return NullLogger.instance;\n  }\n  if (logger.log) {\n    return logger;\n  }\n  return new ConsoleLogger(logger);\n}\n/** @private */\nvar Subject = /** @class */function () {\n  function Subject(cancelCallback) {\n    this.observers = [];\n    this.cancelCallback = cancelCallback;\n  }\n  Subject.prototype.next = function (item) {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n      observer.next(item);\n    }\n  };\n  Subject.prototype.error = function (err) {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n      if (observer.error) {\n        observer.error(err);\n      }\n    }\n  };\n  Subject.prototype.complete = function () {\n    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\n      var observer = _a[_i];\n      if (observer.complete) {\n        observer.complete();\n      }\n    }\n  };\n  Subject.prototype.subscribe = function (observer) {\n    this.observers.push(observer);\n    return new SubjectSubscription(this, observer);\n  };\n  return Subject;\n}();\nexport { Subject };\n/** @private */\nvar SubjectSubscription = /** @class */function () {\n  function SubjectSubscription(subject, observer) {\n    this.subject = subject;\n    this.observer = observer;\n  }\n  SubjectSubscription.prototype.dispose = function () {\n    var index = this.subject.observers.indexOf(this.observer);\n    if (index > -1) {\n      this.subject.observers.splice(index, 1);\n    }\n    if (this.subject.observers.length === 0) {\n      this.subject.cancelCallback().catch(function (_) {});\n    }\n  };\n  return SubjectSubscription;\n}();\nexport { SubjectSubscription };\n/** @private */\nvar ConsoleLogger = /** @class */function () {\n  function ConsoleLogger(minimumLogLevel) {\n    this.minimumLogLevel = minimumLogLevel;\n  }\n  ConsoleLogger.prototype.log = function (logLevel, message) {\n    if (logLevel >= this.minimumLogLevel) {\n      switch (logLevel) {\n        case LogLevel.Critical:\n        case LogLevel.Error:\n          console.error(LogLevel[logLevel] + \": \" + message);\n          break;\n        case LogLevel.Warning:\n          console.warn(LogLevel[logLevel] + \": \" + message);\n          break;\n        case LogLevel.Information:\n          console.info(LogLevel[logLevel] + \": \" + message);\n          break;\n        default:\n          // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\n          console.log(LogLevel[logLevel] + \": \" + message);\n          break;\n      }\n    }\n  };\n  return ConsoleLogger;\n}();\nexport { ConsoleLogger };\n/** @private */\nexport function isArrayBuffer(val) {\n  return val && typeof ArrayBuffer !== \"undefined\" && (val instanceof ArrayBuffer ||\n  // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\n  val.constructor && val.constructor.name === \"ArrayBuffer\");\n}","map":{"version":3,"names":["LogLevel","NullLogger","Arg","isRequired","val","name","undefined","Error","isIn","values","getDataDetail","data","includeContent","length","isArrayBuffer","byteLength","formatArrayBuffer","view","Uint8Array","str","forEach","num","pad","toString","substr","sendMessage","logger","transportName","httpClient","url","accessTokenFactory","content","logMessageContent","token","_b","sent","headers","_a","log","Trace","post","response","statusCode","createLogger","ConsoleLogger","Information","instance","Subject","cancelCallback","observers","prototype","next","item","_i","observer","error","err","complete","subscribe","push","SubjectSubscription","subject","dispose","index","indexOf","splice","catch","_","minimumLogLevel","logLevel","message","Critical","console","Warning","warn","info","ArrayBuffer","constructor"],"sources":["../../src/Utils.ts"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { IStreamResult, IStreamSubscriber, ISubscription } from \"./Stream\";\r\n\r\n/** @private */\r\nexport class Arg {\r\n    public static isRequired(val: any, name: string): void {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n\r\n    public static isIn(val: any, values: any, name: string): void {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getDataDetail(data: any, includeContent: boolean): string {\r\n    let length: string = null;\r\n    if (isArrayBuffer(data)) {\r\n        length = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            length += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    } else if (typeof data === \"string\") {\r\n        length = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            length += `. Content: '${data}'.`;\r\n        }\r\n    }\r\n    return length;\r\n}\r\n\r\n/** @private */\r\nexport function formatArrayBuffer(data: ArrayBuffer): string {\r\n    const view = new Uint8Array(data);\r\n\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n\r\n/** @private */\r\nexport async function sendMessage(logger: ILogger, transportName: string, httpClient: HttpClient, url: string, accessTokenFactory: () => string | Promise<string>, content: string | ArrayBuffer, logMessageContent: boolean): Promise<void> {\r\n    let headers;\r\n    const token = await accessTokenFactory();\r\n    if (token) {\r\n        headers = {\r\n            [\"Authorization\"]: `Bearer ${token}`,\r\n        };\r\n    }\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, logMessageContent)}.`);\r\n\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers,\r\n    });\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n\r\n/** @private */\r\nexport function createLogger(logger?: ILogger | LogLevel) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n\r\n    if ((logger as ILogger).log) {\r\n        return logger as ILogger;\r\n    }\r\n\r\n    return new ConsoleLogger(logger as LogLevel);\r\n}\r\n\r\n/** @private */\r\nexport class Subject<T> implements IStreamResult<T> {\r\n    public observers: Array<IStreamSubscriber<T>>;\r\n    public cancelCallback: () => Promise<void>;\r\n\r\n    constructor(cancelCallback: () => Promise<void>) {\r\n        this.observers = [];\r\n        this.cancelCallback = cancelCallback;\r\n    }\r\n\r\n    public next(item: T): void {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n\r\n    public error(err: any): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    public complete(): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n\r\n    public subscribe(observer: IStreamSubscriber<T>): ISubscription<T> {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class SubjectSubscription<T> implements ISubscription<T> {\r\n    private subject: Subject<T>;\r\n    private observer: IStreamSubscriber<T>;\r\n\r\n    constructor(subject: Subject<T>, observer: IStreamSubscriber<T>) {\r\n        this.subject = subject;\r\n        this.observer = observer;\r\n    }\r\n\r\n    public dispose(): void {\r\n        const index: number = this.subject.observers.indexOf(this.observer);\r\n        if (index > -1) {\r\n            this.subject.observers.splice(index, 1);\r\n        }\r\n\r\n        if (this.subject.observers.length === 0) {\r\n            this.subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class ConsoleLogger implements ILogger {\r\n    private readonly minimumLogLevel: LogLevel;\r\n\r\n    constructor(minimumLogLevel: LogLevel) {\r\n        this.minimumLogLevel = minimumLogLevel;\r\n    }\r\n\r\n    public log(logLevel: LogLevel, message: string): void {\r\n        if (logLevel >= this.minimumLogLevel) {\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    console.error(`${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    console.warn(`${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    console.info(`${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    console.log(`${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n        // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n        (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}